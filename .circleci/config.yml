version: 2.1

# Think of orbs as libraries or packages for CircleCI
orbs:
  slack: circleci/slack@4.5.0
  aws-cli: circleci/aws-cli@2.0.6
  aws-eks: circleci/aws-eks@1.1.0
  browser-tools: circleci/browser-tools@1.2.3
  #kubernetes: circleci/kubernetes@0.12.1

# These are custom functions that I use in other jobs
commands:
  # Function 1
  notify_slack_error:
    steps:
      - slack/notify:
          event: fail
          template: basic_fail_1 # build in formating template to display failure
          mentions: "@ugochi" #if you want to target a particular person
          channel: alerts # Slack channel to display to

  # Function 2
  destroy-docker-image:
    description: Destroy Docker Image
    parameters:
      # Add parameter here
      docker_image_tag:
        type: string
        default: latest
      docker_container_name:
        type: string
        default: NONE
    steps:
      - checkout
      - run:
          name: Destroy Docker Image
          when: on_fail
          command: |
            # Your code here
            ./docker/cleanup_docker_image.sh <<parameter.docker_image_tag>> <<parameter.docker_container_name>>


  # Function 3
  destroy-environment:
    description: Destroy Cloudformation Stacks Given A Workflow ID.
    parameters:
      # Add parameter here
      workflow_id:
        type: string
    steps:
      - run:
          name: Destroy Environments
          when: on_fail
          command: |
            # Use for roll back
            # Delete any infrastructure created.
            aws cloudformation delete-stack --stack-name "dagster-network-stack-<<parameters.workflow_id>>"

jobs:
  lint:
    docker: 
      # This image has poetry, pyenv, pip, pipenv, and python 3.10 pre-installed
      # https://hub.docker.com/r/cimg/python
      - image: cimg/python:3.9.7

    steps:
      - checkout
      # Use the chown command to grant CircleCI access to dependency locations
      - run: sudo chown -R circleci:circleci /usr/local/bin
      - restore_cache:
          keys:
          - v1-dependencies-{{ checksum "pyproject.toml" }}
          # fallback to using the latest cache if no exact match is found, so checksum failed
          - v1-dependencies-
      - run:
          name: Install Tools & Dependencies
          command: |
            
            # Create Environment
            python -m venv capstone
            . capstone/bin/activate
            echo -e "VIRTUAL_ENV=${VIRTUAL_ENV}\n"

            # Check linux operating system of docker container
            cat /etc/os-release

            # install tools
            make setup

            # Install python packages
            make pip-install

            make lint

      - save_cache:
          name: Save Python Virtualenv Dependencies
          key: v1-dependencies-{{ checksum "pyproject.toml" }}
          paths:
            - /usr/local/bin # Binaries of dependencies
            - capstone

      #- slack/notify # I need to add a SLACK TOKEN to enable this.
  
  # Making sure unittest pass
  test_code:
    docker: 
      # This image has poetry, pyenv, pip, pipenv, and python 3.10 pre-installed
      # https://hub.docker.com/r/cimg/python
      - image: cimg/python:3.9.7
    steps:
      - checkout
      # Use the chown command to grant CircleCI access to dependency locations
      - run: sudo chown -R circleci:circleci /usr/local/bin
      - restore_cache:
          keys:
          - v1-dependencies-{{ checksum "pyproject.toml" }}
          # fallback to using the latest cache if no exact match is found
          - v1-dependencies-
    
      - run: 
          name: Activate Environment
          command: |
            . capstone/bin/activate
            echo -e "VIRTUAL_ENV=${VIRTUAL_ENV}\n"
            pip list

      # I have to activate the virtual environment to get his to work.
      - run:
          name: Run Dagster Tests
          command: |
            . capstone/bin/activate # Why would I need to do this again?
            make test
      #- slack/notify # I need to add a SLACK TOKEN to enable this.

  # Build container and make sure browser test passes
  # More about URL servers
  build-and-deploy-image:
    docker:
      #- image: cimg/python:3.9.7
      - image: docker:20.10.11-git
    working_directory: ~/project/dagster
    steps:
      - checkout
      - aws-cli/install
      # Need to deploy to ECR
      - aws-cli/setup:
          aws-region: AWS_DEFAULT_REGION
          aws-access-key-id: AWS_ACCESS_KEY_ID
          aws-secret-access-key: AWS_SECRET_ACCESS_KEY
          profile-name: AWS_PROFILE_NAME
      - setup_remote_docker 
      - restore_cache:
          keys:
            - v1-{{ .Branch }}

      - run:
          name: Print OS
          command: |
            # Check linux operating system of docker container
            cat /etc/os-release
  
      - run:
          name: Load Docker image layer cache
          command: |
            # The following command says, if you want the command to fail due to an error at any stage 
            # when pipe(|) output of a command to another command
            set +o pipefail 
            docker load -i /caches/dagster-app.tar | true

      - run: 
          name: Build Dagster Image
          command: |
            # Your stack command code here
            echo "Building image..."
            cd dagster
            TAG="dagster-app:v1.${CIRCLE_WORKFLOW_ID}"
            echo $TAG
            docker build --cache-from=dagster-app --tag $TAG .
      - run:
          name: Save Docker image layer cache
          command: |
            mkdir -p /caches
            docker save -o /caches/dagster-app.tar dagster-app
      - save_cache:
          key: v1-{{ .Branch }}-{{ epoch }}
          paths:
            - /caches/dagster-app.tar
      - run:
          name: Test Dagster Container
          command: |
            cd dagster
            docker run -d -p 3000:3000 --name dagster-cntr-${CIRCLE_WORKFLOW_ID} dagster-app
            URL=localhost:3000
            echo "URL = $URL"

            # Check if can connect
            if curl $URL
            then
                echo "SUCCESS(+): Connected to Dagster UI\n"
            else
                echo "FAILURE(-): Failed to connect to Dagster"
                docker stop dagster-cntr-${CIRCLE_WORKFLOW_ID}
                exit 1
            fi

            # Check if it found relevant word.
            if curl $URL | grep "Dagit"
            then
                echo "SUCCESS(++): found $2 in document: $URL\n"
                docker stop dagster-cntr-${CIRCLE_WORKFLOW_ID}
                exit 0
            else
                echo "FAILURE(--): Failed to find $2 in document: $URL"
                docker stop dagster-cntr-${CIRCLE_WORKFLOW_ID}
                exit 1
            fi
      - deploy:
          name: Deploy Image to ECR
          command: |
            if [ "${CIRCLE_BRANCH}" == "main" ]; then
              login="$(aws ecr get-login)"
              ${login}
              docker tag dagster-app:v1.${CIRCLE_WORKFLOW_ID} "${AWS_ECR_REPO_URI}/dagster-app:${CIRCLE_SHA1}"
              docker push "${AWS_ECR_REPO_URI}/dagster-app:${CIRCLE_SHA1}"
            fi
          
  
  test_ui:
    docker:
      - image: cimg/python:3.9.7
    steps:
      - checkout
      # To enable docker commands need the following step
      - setup_remote_docker:
          version: 20.10.7
      - run: sudo chown -R circleci:circleci /usr/local/bin
      - restore_cache:
          keys:
          - v1-dependencies-{{ checksum "pyproject.toml" }}
          # fallback to using the latest cache if no exact match is found
          - v1-dependencies-
      - browser-tools/install-chrome
      - browser-tools/install-chromedriver
      - run:
          name: Check Chrome Install
          command: |
            google-chrome --version
            chromedriver --version
          
      - run: 
          name: Build Dagster Image
          command: |
            # Your stack command code here
            echo "Building image..."

      - run: 
          name: Run Container
          command: |
            echo "Starting container"

      - run:
          name: Download Selenium Server
          command: |
            # sudo apt install wget # If not already installed uncomment
            #url -O https://github.com/SeleniumHQ/selenium/releases/download/selenium-4.1.0/selenium-server-4.1.0.jar
            wget https://github.com/SeleniumHQ/selenium/releases/download/selenium-4.1.0/selenium-server-4.1.0.jar
            
      - run:
          name: Start Selenium
          command: |
            java -jar selenium-server-4.1.0.jar -log test-reports/selenium.log
          background: true
      - run: 
          name: Test Dagster Site
          command: |
            # Smoke Test for Dagster Site
            echo "Starting smoke test..."
  
  # Upload container to repository
  # upload_image:
  #   docker:
  #     - image: cimg/python:3.9.7
  #   steps: 
  #     - checkout
  #     - run: sudo chown -R circleci:circleci /usr/local/bin
  #     - restore_cache:
  #         keys:
  #         - v1-dependencies-{{ checksum "pyproject.toml" }}
  #         # fallback to using the latest cache if no exact match is found
  #         - v1-dependencies-
  #     - run: 
  #         name: Upload Image
  #         command: |
  #           # Your stack command code here
  #           echo "Upload image..."
  # End of Continuous Integration, Start of Continuous Delivery
  
  deploy_network_infrastructure:
    docker:
      - image: cimg/python:3.9.7
    steps: 
      - checkout
      - aws-cli/install:
          override-installed: true
      - run: 
          name: Deploy stack
          command: |
            # Your stack command code here
            echo "Deploying stack..."

# Workflows
# ----------------------
workflows:
  default:
    jobs:
      - lint

      - test_code:
          requires: [lint] # I need the dependencies to be created first
      
      - build-and-deploy-image:
          requires: [test_code]

      # END OF CONTINUOUS INTEGRATION, START CONTINUOUS DELIVERY
      
      # Want everything in my VPC, so deploying aws infrastructure
      # - deploy_infrastucture:
      #     requires: [upload_image]
      #     filters:
      #       branches:
      #         only: [main]

      # Create EKS cluster (if not already created)

      # Manually approve cleanup?
      #- hold:
      #    type: approval